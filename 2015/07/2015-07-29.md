## ES6

### [ES6 In Depth: Generators, continued](https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/)

* The action is synchronous and single-threaded

#### `generator.return()`

```javascript
function* gen() {
  try {
    yield 'A';
    yield 'B';
    yield 'C';
    // ... yield some more values ...
  } finally {
    console.log('cleaning up');
  }
}

var generator = gen();
for (var value of generator) {
  console.log(value);
  if (value === 'B')
    generator.return();  // shows 'cleaning up', and no 'C' later
}
```
* If you call `generator.return()`, the `finally` block in the generator will be executed
  * Good for exceptions/early breaks
  * Note: it's like change the `yield` in your generator into `return`, which will also cause the `finally` block to be executed
* Not supported in Chrome yet: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)
* It's possible for a generator to be garbage collected before executing its `finally` block(e.g. you directly `break` out of the `for-of` without calling `generator.return()`)
* Usually you use it like this:

  ```javascript
  for (var value of generator) {
    try {
      // do something with value
    } catch {
      generator.return();
      // do its own error handling
    }
  }
  ```

#### Generator for async operation

* The key is: inside a generator function, `yield` can return a value. It returns what's passed by the caller in `generator.next(something)`, which means you have a way to let the generator know what to do next by using the information passed by its caller.
* So your generator function can not only pass things to its caller, but also receive things from its caller -- and most importantly, what it receives can be changed over each stage! (It's not like your normal parameter passing because in that case you can only pass data once at the beginning)
* Typically, you `yield` promises
* In this way, you can keep calling generators, **pass its return value to itself** until it finishes:

  ```javascript
  function runGeneratorOnce(g, result) {
    var status = g.next(result);
    if (status.done) {
      return;  // phew!
    }

    // The generator has asked us to fetch something and
    // call it back when we're done.
    doAsynchronousWork(
      status.value,
      (error, nextResult) => runGeneratorOnce(g, nextResult));
  }

  function * generator() {
    var b = yield 'A';
    var c = yield b;
    var d = yield c;
  }
  ```